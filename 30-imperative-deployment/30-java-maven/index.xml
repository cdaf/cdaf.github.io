<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java and Maven Example on Concepts &amp; Applied Examples</title>
    <link>/30-imperative-deployment/30-java-maven/</link>
    <description>Recent content in Java and Maven Example on Concepts &amp; Applied Examples</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="/30-imperative-deployment/30-java-maven/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Continuous Integration (CI)</title>
      <link>/30-imperative-deployment/30-java-maven/20-ci/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/30-imperative-deployment/30-java-maven/20-ci/</guid>
      <description>Build &amp;amp; Package Once To provide a runtime verification of the build that has been deployed, the version is automatically incremented by placing a variable in the pom.xml file
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; .. &amp;lt;artifactId&amp;gt;springboot&amp;lt;/artifactId&amp;gt; &amp;lt;groupId&amp;gt;io.cdaf&amp;lt;/groupId&amp;gt; &amp;lt;name&amp;gt;Spring Boot Data REST Sample&amp;lt;/name&amp;gt; &amp;lt;description&amp;gt;Spring Boot Data REST Sample&amp;lt;/description&amp;gt; &amp;lt;version&amp;gt;0.2.${build.number}&amp;lt;/version&amp;gt; In the build task, the build number is supplied as a maven parameter
mvn --batch-mode --file springboot/pom.xml package -D&amp;#34;build.number=${BUILDNUMBER}&amp;#34; The resulting artefact is in a subdirectory, buy using the -flat parameter in storeForLocal the artefact will be placed in the root of release package.</description>
    </item>
    
    <item>
      <title>Continuous Delivery (CD)</title>
      <link>/30-imperative-deployment/30-java-maven/30-cd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/30-imperative-deployment/30-java-maven/30-cd/</guid>
      <description>Deploy Many While this example does not delivery the software component imperatively, i.e. it is release declaratively via the Release Train, a Continuous Delivery stage is still performed, however this is a closed loop process, where docker-compose is used to stand-up a container instance from the image, stand-up another container to perform a smoke test, and then tear down the stack.
services: target: image: &amp;#34;${TARGET_TAG}&amp;#34; test: image: &amp;#34;${TEST_TAG}&amp;#34; links: - target:target depends_on: - target </description>
    </item>
    
  </channel>
</rss>
